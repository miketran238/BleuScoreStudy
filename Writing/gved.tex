\subsubsection{\textbf{Graph Vector Edit Distance (GVED)}} 
Structure-oriented approaches in code semantic comparision have become popular in programming. In many popular tructure-orientedd approaches nowadays, Exas is an accurate and efficient structural characteristic feature extraction approach that better approximates and captures the structure within the fragments of artifacts.\cite{Accurate and Efficient Structural Characteristic Feature Extraction for Clone Detection}.
In our study area, we use Exas as a mean of computing the difference between code structure. Given a pair of method in C\# which are need to be compared their structure, GROUM [cite GROUM] is used to parse code into program dependence graphs (PDGs) [cite to PDG] and Exas continues processing these graphs. In Exas, the characteristic features are extracted from the patterns of elements of the graphs. The code fragments are characterized by their counting vectors of those features. The difference between two vectors reflects the difference of two graphs.  Therefore, distance of these counting vectors is considered the way to measure the sematic between code fragments.

We introduce the formuala for normalizing the result of vector edit distance which is used in the next part of the paper. The normalized value is described as

$GVED(V1, V2) = 1 - \sum_{i=1}^{n} \frac{ \mid XV1_i - XV2_i \mid}{XV1_i + XV2_i}$, 
where $n$ denotes the number of vector scalar, $V1$ denotes the counting vector of the first graph, $V2$ denotes the counting vector of the second graph, $XV1_i$ denotes $V1$\rq the value of the $i-th$ scalar, $XV2_i$ denotes $V2$\rq the value of the $i-th$ scalar.  

Below is an example of computing GVED between two code fragments. Figure 3 shows an illustrated PGDs  of a code fragment 1 and fragment 2 which are parsed by GROUM.
\begin{lstlisting}[language=JAVA]
	Code 1:
	void foo(int i) {
		int j;
		if (i < 2) {
			j = 1;
		} else {
			j = 2;
		}
	}

	Code 2:
	void foo(int i) {
		int j;
		if (i < 2) 
			j = i;	 
		j = 2;
	}
\end{lstlisting}
\begin{figure}[h]
	\caption{An example: two PDGs represent code1 and code2}
	\includegraphics[scale=0.4]{img/Diagram_PDG.png}
	\centering
	\label{fig:PDGs}
\end{figure}

% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[htbp]
  \centering
  \caption{Feature table of code1 extracted in Exas}
  \scalebox{0.65}{
    \begin{tabular}{|l|l|l|l|l|r|}
    \toprule
    \textbf{Pattern} & \multicolumn{5}{c|}{\textbf{Feature of Code1}} \\
    \midrule
    \textit{\textbf{1-path}} & inputInt & intSmall2 & intEqual1 & intEqual2 & \multicolumn{1}{l|}{declareInt} \\
    \midrule
    \textit{\textbf{2-path}} & \multicolumn{1}{p{6.415em}|}{inputInt-intSmall2} & \multicolumn{1}{p{5.915em}|}{intSmall2-intEqual1} & \multicolumn{1}{p{6em}|}{intSmall2-intEqual2} & \multicolumn{1}{p{5.75em}|}{declareInt-intEqual1} & \multicolumn{1}{p{5em}|}{declareInt-intEqual2} \\
    \midrule
    \textit{\textbf{3-path}} & \multicolumn{1}{p{6.415em}|}{intputInt-intSmall2-intEqual1} & \multicolumn{1}{p{5.915em}|}{intputInt-intSmall2-intEqual2} &       &       &  \\
    \midrule
    \textit{\textbf{(p,q)-node}} & inputInt-0-1 & intSmall2-1-2 & intEqual1-2-0 & intEqual2-1-2 &  \\
    \bottomrule
    \end{tabular}%
	}
  \label{tab:addlabel}%
\end{table}%

% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[htbp]
  \centering
	\caption{Feature table of code2 extracted in Exas}
	\scalebox{0.65}{
	    \begin{tabular}{|l|l|l|l|l|r|}
    \toprule
    \textbf{Pattern} & \multicolumn{5}{c|}{\textbf{Feature of Code2}} \\
    \midrule
    \textit{\textbf{1-path}} & inputInt & intSmall2 & intEqualInt & intEqual2 & \multicolumn{1}{l|}{declareInt} \\
    \midrule
    \textit{\textbf{2-path}} & \multicolumn{1}{p{6.415em}|}{inputInt-intSmall2} & \multicolumn{1}{p{5.915em}|}{intSmall2-intEqualInt} & \multicolumn{1}{p{6em}|}{declareInt-intEqual1} & \multicolumn{1}{p{5.75em}|}{declareInt-intEqual2} &  \\
    \midrule
    \textit{\textbf{3-path}} & \multicolumn{1}{p{6.415em}|}{intputInt-intSmall2-intEqualInt} &       &       &       &  \\
    \midrule
    \textit{\textbf{(p,q)-node}} & inputInt-0-1 & intSmall2-1-1 & intEqualInt-2-0 & intEqual2-1-0 &  \\
    \bottomrule
    \end{tabular}%
	}
  \label{tab:addlabel}%
\end{table}%

