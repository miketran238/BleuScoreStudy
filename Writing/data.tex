\subsection{Data Collection}

For our study, we collected a dual corpus of \textbf{34,209} pairs of
methods written in both Java and C\#. Those methods were created
manually by developers, and used in \textbf{9} open-source systems
that were originally developed in Java and then ported to C\#. They
are well-recognized systems such that both Java and C\# versions have
been used in practice and research~\cite{ase15}.

Not all of the methods in Java version has a respective one in the C\#
version. To collect respective methods in each pair of corresponding
versions, we built a tool to conservatively search for only the
methods having the same signatures in the classes with the
same/similar names in the same/similar directory structures in both
versions. Such pairs of methods likely implement the same
functionality. We aslo manually verified a small, randomly selected
sample set to have high confidence that the method pairs are in fact
the respective ones. In total, there were 34,209 respective methods
\textbf{(Table \ref{table:methods})}.

\begin{table}
\begin{tabular}{|c | c|}
\hline
Projects & Number of matched paris of methods \\
\hline
Antlr & 912 \\
db40 & 8,467 \\
fpml & 506	\\
Itext & 2,958	\\
Jgit & 6,021 	\\
Jts & 2,015	\\
Lucene & 4,494	\\
Neodatis & 4,395	\\
POI & 4,441 \\
\hline
Total & 34,209 \\
\hline
\end{tabular}
\caption{Pairs of matched methods across systems}
\label{table:methods}
\end{table}

We used the two SMT-based migration tools (lpSMT and mppSMT) on the
above dataset. We applied ten-fold cross validation by dividing all
aligned methods into ten folds with equal numbers of methods. To test
for a fold, we used the remaining folds for training. The resulting
methods were compared against the referenced ones in the oracle. We
used 4 metrics to evaluate.

