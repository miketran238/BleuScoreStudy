\section{Proposed Metric}
%\subsection{\model}

%BLEU has always been doing this and that....

%Researchers usually claim that an improvement in BLEU also meant an
%improvement in translation quality. So 

%BLEU has been used for not only evaluating the result but also tuning
%and developing SMT-based migration system.
%%From the results in section 5, BLEU did not reflect the semantic accuracy of source code. --> We need a better metrics to replace BLEU
%However, from the results in section 5, it can be concluded that BLEU
%did not reflect well the semantic accuracy of migrated source code
%since it has weak relation with human judgments. Therefore, we need a
%better metric in order to fit better with programming languages and
%code migration systems.
%%
%%Needed metric should be 
%%Reflect semantical meaning of sources code.
%%Automated
%%Low computation's cost
%%Independent of programming language
%%Independent of MT model's type
%Such a metric should have the following requirements:
%
%
%\emph{1}. The metric is more suitable for source code than BLEU. It
%can reflect the semantics of source code and the semantic accuracy of
%translation result. To fulfill that, the metric must have high
%correlation with human evaluation for the translation result.
%
%
%\emph{2}. The metric can be computed automatically and inexpensively in
%order to support the evaluation of migration results in the
%incremental development of SMT-based code migration systems. For
%example, the metric can be calculated quickly after each iteration of
%development so a system can be evaluated and tuned in a timely~manner.
%
%\emph{3}. The metric is independent of the programming languages and
%of the SMT models. A good and reliable metric must have consistent
%results for any languages and models so it can be applied universally
%to any SMT-based code migration systems.
%
%%What is Ruby and why Ruby is good.
%Considering all above requirements, we introduce {\model}, a novel automated metric that can reflect semantic accuracy of translated code. {\model} is also independent of programming languages and machine translation models used in migration system. {\model} measures the semantic accuracy of the resulting code with respect to reference code by comparing their Program Dependence Graph (PDG). PDG captures both the data and control dependencies among program entities. Because those dependencies play an important role in a program, we expect PDG can represent well the semantics of source code. Usually, comparing graph is expensive, but our approach makes it affordable. We estimate the graph edit distance by vectorizing the graph and calculating the vectors edit distance. Because of that, we can save the computational cost and make our approach scalable. Basically, every programming language code can be built into PDG. Hence, our metric can be used for Code Migration systems that migrate different programming languages. Lastly, the way {\model} is measured makes it independent of machine translation models. That means Code Migration systems that deployed different SMT models can still use our metric. Next, we go into details how to formalize the calculation of {\model}
%
%%To reduce the high computational cost, we vectorize the PDGs and calculate the vector difference to estimate the graph difference. This way, we would make sure that our model is practical and applicable in large scaled systems. 
%
%When applying MT on source code, there always exists the problem that the translated code is broken in term of syntax. Thus, it is impossible to build PDG or even compile those code. To cope with the problem, our model is designed as best-effort, layered metric  : If the translated code can be built into PDG, we calculate {\model} in term of graph edit distance. If the translated code cannot be built into PDG but is compilable, we calculate {\model} in term of syntax tree edit distance. If the translated code is not compilable, we calculate {\model} in term of string edit distance. We then represent about the 3 metrics graph/tree/string edit distances as follows:


 {\model} can be calculated as follows: 
%if (GVED(s,t) != -1) RUBY(s,t) = GVED(s,t)\\
%else if (TREED(s,t) != -1) RUBY(s,t) = TREED(s,t)\\
%else RUBY(s,t) = SED(s,t)

%$\mbox{RUBY}\left(s,t\right) = \begin{cases} 
%\mbox{GVED}\left(s,t\right), & \mbox{if } \mbox{GVED}\left(s,t\right) \mbox{ is applicable}\\ 
%\mbox{TED}\left(s,t\right), & \mbox{if } n\mbox{ is odd} 
%\end{cases}$

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\begin{algorithm}
\caption{Calculate {\model}}\label{euclid}
\begin{algorithmic}[1]
\If { $\mbox{GVED}\left(r,t\right) $ is applicable }
\State $\mbox{RUBY}\left(r,t\right) = \mbox{GVED}\left(r,t\right) $
\ElsIf { $\mbox{TREED}\left(r,t\right) $ is applicable }
\State $\mbox{RUBY}\left(r,t\right) = \mbox{TREED}\left(r,t\right) $
\Else 
\State $\mbox{RUBY}\left(r,t\right) = \mbox{SED}\left(r,t\right) $
\EndIf
%\Procedure{MyProcedure}{}
%\State $\textit{stringlen} \gets \text{length of }\textit{string}$
%\State $i \gets \textit{patlen}$
%\BState \emph{top}:
%\If {$i > \textit{stringlen}$} \Return false
%\EndIf
%\State $j \gets \textit{patlen}$
%\BState \emph{loop}:
%\If {$\textit{string}(i) = \textit{path}(j)$}
%\State $j \gets j-1$.
%\State $i \gets i-1$.
%\State \textbf{goto} \emph{loop}.
%\State \textbf{close};
%\EndIf
%\State $i \gets i+\max(\textit{delta}_1(\textit{string}(i)),\textit{delta}_2(j))$.
%\State \textbf{goto} \emph{top}.
%\EndProcedure
\end{algorithmic}
\end{algorithm}
